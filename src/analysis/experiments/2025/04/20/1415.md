# 実験レポート：300 件サンプルデータの特徴分析

## 実験概要

- 実験日時：2025-04-20 14:15
- 実験者：清野駿
- 実験 ID：batch_analysis_001

## 目的

本研究の最終目標は、AI 同士の言語創発実験において生成されるメッセージの意味を人間の言葉へと翻訳可能な説明可能 AI を構築することです。その第一段階として、本実験では以下を検証します：

1. GPT による特徴判定の信頼性評価

   - 300 件のレビューサンプルに対して特徴検出を実行
   - 人間の目で評価し、明らかな誤判定が 10%以下であることを確認
   - 特徴判定の一貫性（同じような表現に対する判定の安定性）を検証

2. 特徴判定手法の確立
   - 20 種類の特徴について、GPT が適切に判定できるか検証
   - 判定が困難な特徴カテゴリの特定
   - 判定プロンプトの有効性評価

これらの検証を通じて、後続の研究段階（AI モデル間メッセージの意味理解）に向けた特徴抽出の基盤を確立します。

## 実験条件

- 使用モデル：gpt-4.1-mini
- パラメータ：
  - temperature: 0.7
  - 各レビュー 5 回試行
  - バッチサイズ：10 件
- 特徴リストの要素数：20
- 分析対象：電化製品レビュー 300 件（レーティング分布を保持したランダムサンプリング）

## プロンプト

```prompt
You are an expert in analyzing product reviews.
Please evaluate whether each feature applies to the following product review.
Clearly indicate your judgment with 0 (feature not present) or 1 (feature present).

[REVIEW]
{review_text}

[REVIEW RATING]
{rating}

[FEATURE LIST]
{features_list}

Response format:
{
    "features": {
        "1": 0 or 1,
        "2": 0 or 1,
        ...
    }
}
```

## 実験データ

- 入力データ：
  - ファイル：src/data/examples/sample_reviews_300.csv
  - 件数：298 件
  - 特徴：電化製品レビュー、英語テキスト
  - サンプリング方法：レーティング分布を保持したストラティファイドサンプリング
- 出力結果：
  - 保存先：[src/analysis/results_batch_analysis/20250420_1435/](../../../../results_batch_analysis/20250420_1435/)
  - 形式：
    - JSON（中間結果）：10 件ごとの分析結果
    - CSV（詳細結果）：各レビューの特徴分析結果（時刻\_タイトル.csv 形式）
    - MD（サマリーレポート）：全体の分析結果とレーティング分布

## 実験結果

### データ

- [summary](./summary_report.md)
- [all_results](./all_results.json)

### 分析概要

- 分析対象レビュー数: 299 件
- レーティング分布:
  - 1.0 星: 17 件 (5.7%)
  - 2.0 星: 13 件 (4.3%)
  - 3.0 星: 25 件 (8.4%)
  - 4.0 星: 64 件 (21.4%)
  - 5.0 星: 180 件 (60.2%)

### 特徴分析結果

| 特徴 ID | 特徴内容                       | 出現数 | 出現率 | 平均安定性 |
| ------- | ------------------------------ | ------ | ------ | ---------- |
| 5       | 具体的な使用事例や目的の説明   | 216    | 72.2%  | 0.99       |
| 12      | 製品の耐久性や品質への言及     | 174    | 58.2%  | 0.98       |
| 7       | 製品の制限や欠点への言及       | 162    | 54.2%  | 0.99       |
| 18      | 製品の使用環境の説明           | 134    | 44.8%  | 0.98       |
| 1       | 価格やコストへの言及           | 132    | 44.1%  | 0.99       |
| 8       | 以前使用した類似製品との比較   | 125    | 41.8%  | 0.99       |
| 2       | 技術的な詳細や仕様への言及     | 115    | 38.5%  | 0.98       |
| 19      | 期待との一致/不一致への言及    | 115    | 38.5%  | 0.96       |
| 3       | 競合製品との比較               | 110    | 36.8%  | 0.98       |
| 11      | 予期せぬ問題や発見の報告       | 98     | 32.8%  | 0.98       |
| 4       | 長期使用経験の言及             | 93     | 31.1%  | 0.99       |
| 10      | 購入決定プロセスの説明         | 73     | 24.4%  | 0.98       |
| 20      | 他のユーザーへのアドバイス     | 70     | 23.4%  | 0.98       |
| 15      | 推奨ユーザー層の明示           | 68     | 22.7%  | 0.99       |
| 6       | 初期セットアップの経験         | 47     | 15.7%  | 0.99       |
| 16      | 梱包や付属品への言及           | 45     | 15.1%  | 0.99       |
| 9       | ブランドの信頼性・評判への言及 | 43     | 14.4%  | 0.99       |
| 14      | 改善提案の提示                 | 43     | 14.4%  | 1.00       |
| 13      | 返品・交換の意向               | 15     | 5.0%   | 1.00       |
| 17      | カスタマーサポートの経験       | 9      | 3.0%   | 1.00       |

### 判定の安定性

- 全特徴の平均安定性: 0.98
- 最高安定性（1.00）:
  - 返品・交換の意向（ID 13）
  - 改善提案の提示（ID 14）
  - カスタマーサポートの経験（ID 17）
- 最低安定性（0.96）:
  - 期待との一致/不一致への言及（ID 19）

## 考察 (AI による分析)

### 特徴の出現パターンについて()

特徴の出現率を分析したところ、興味深いパターンが観察されました：

1. 高頻度で出現する特徴（70%以上）

   - 具体的な使用事例や目的の説明（72.2%）
     これは購入者が自身の利用文脈を重視してレビューを書く傾向を示唆しています。

2. 中頻度で出現する特徴（40-60%）
   以下の特徴群は、レビューの信頼性や有用性を高める要素として機能していると考えられます：

   a) 客観的な評価要素

   - 価格やコストへの言及（44.1%）
   - 技術的な詳細や仕様（38.5%）
   - 製品の制限や欠点（54.2%）

   b) 比較的視点

   - 類似製品との比較（41.8%）
   - 期待との一致/不一致（38.5%）

   c) コンテキスト情報

   - 使用環境の説明（44.8%）
   - 制限事項の指摘（54.2%）

   これらの特徴は、主観的な評価ではなく、より客観的な事実や比較に基づく記述という共通点を持っています。
   約半数のレビューがこれらの特徴を含んでいることは、レビューの情報的価値の高さを示唆しています。

3. 低頻度で出現する特徴（15%以下）

   - カスタマーサポートの経験（3.0%）
   - 返品・交換の意向（5.0%）
   - ブランドの信頼性・評判（14.4%）

   これらの特徴の低出現率は、製品自体への満足度の高さ（5 星評価 60.2%）と整合的です。

## 補足資料

### 参考文献・リソース

- OpenAI GPT-4.1-mini API
- pandas 2.0+

## 付録：実験コード

### create_sample_dataset.py

```python
"""
レビューデータから300件をランダムにサンプリングするスクリプト

## ストラティファイドサンプリング（層化抽出法）について
ストラティファイドサンプリングとは、母集団をある特性（この場合はレーティング）に基づいて
複数の層（stratum）に分け、各層から元の比率を保持しながらサンプリングを行う手法です。

### なぜレーティング分布を保持するのか
1. 代表性の確保
   - 商品レビューデータでは、レーティングの分布が重要な特性
   - 高評価（5星）が多く、低評価（1-2星）が少ない傾向がある
   - 単純なランダムサンプリングでは、少数の層（低評価）が適切に抽出されない可能性

2. 分析の信頼性
   - 特徴検出の精度評価では、各レーティング層での性能を確認する必要がある
   - 特に低評価レビューでの特徴検出が重要（問題点や改善点の抽出）
   - 分布を保持することで、元データと同様の条件での評価が可能
a
3. バイアスの防止
   - 単純ランダムサンプリングでは、偶然により特定のレーティングが過多/過少になる可能性
   - 層化抽出により、各レーティング層の比率を保証
   - 評価実験の再現性と一般性を向上

### 実装方法
1. レーティングごとにグループ化
2. 各グループから、元の分布比率に基づいて抽出
3. 合計が目標サンプルサイズになるように調整
"""

import pandas as pd
from pathlib import Path
import numpy as np

def create_sample_dataset(
    input_file: str = "data/processed/electronics_reviews.csv",
    output_file: str = "data/examples/sample_reviews_300.csv",
    sample_size: int = 300,
    random_state: int = 42
) -> None:
    """
    レビューデータからサンプルデータセットを作成

    Args:
        input_file: 入力ファイルのパス
        output_file: 出力ファイルのパス
        sample_size: サンプリングするデータ数
        random_state: 乱数シード
    """
    # 入力ファイルの読み込み
    print(f"元データの読み込み中: {input_file}")
    df = pd.read_csv(input_file)

    # 元データの情報表示
    print("\n=== 元データの情報 ===")
    print(f"総レビュー数: {len(df)}")
    print("\nレーティング分布:")
    rating_dist = df['rating'].value_counts().sort_index()
    for rating, count in rating_dist.items():
        percentage = (count / len(df)) * 100
        print(f"  {rating}星: {count}件 ({percentage:.1f}%)")

    # レーティングごとの比率を保持したストラティファイドサンプリング
    sampled_df = df.groupby('rating', group_keys=False).apply(
        lambda x: x.sample(
            n=max(1, int(sample_size * len(x) / len(df))),
            random_state=random_state
        )
    )

    # サンプルサイズを厳密に300件に調整
    if len(sampled_df) > sample_size:
        sampled_df = sampled_df.sample(n=sample_size, random_state=random_state)
    elif len(sampled_df) < sample_size:
        # 不足分を全体からランダムに追加
        additional_samples = df.sample(
            n=sample_size - len(sampled_df),
            random_state=random_state
        )
        sampled_df = pd.concat([sampled_df, additional_samples])

    # サンプリング結果の情報表示
    print("\n=== サンプリング結果 ===")
    print(f"サンプル数: {len(sampled_df)}")
    print("\nレーティング分布:")
    sample_dist = sampled_df['rating'].value_counts().sort_index()
    for rating, count in sample_dist.items():
        percentage = (count / len(sampled_df)) * 100
        print(f"  {rating}星: {count}件 ({percentage:.1f}%)")

    # 出力ディレクトリの作成
    output_path = Path(output_file)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # 結果の保存
    sampled_df.to_csv(output_file, index=False)
    print(f"\nサンプルデータを保存しました: {output_file}")

if __name__ == "__main__":
    create_sample_dataset()
```

### review_feature_analyzer.py

````python
"""
1. OpenAI APIを使用してレビューテキストを分析
2. 各特徴について1（当てはまる）または0（当てはまらない）を判定
3. 複数回の分析結果を統計的に処理
"""

import openai
import pandas as pd
import json
from pathlib import Path
from dotenv import load_dotenv
import os
from collections import Counter
from typing import List, Dict
from datetime import datetime
import csv

class ReviewFeatureAnalyzer:
    def __init__(self, output_dir: str = None):
        # .envファイルから環境変数を読み込む
        load_dotenv()

        # 環境変数からAPIキーを設定
        self.client = openai.OpenAI(api_key=os.getenv('OPENAI_API_KEY'))
        if not self.client.api_key:
            raise ValueError("OPENAI_API_KEY not found in environment variables")

        # 特徴定義の読み込み
        self.features_df = pd.read_csv("src/data/features/definitions/review_features.csv")

        # 出力ディレクトリの設定
        self.output_dir = Path(output_dir) if output_dir else Path("src/analysis/experiments")

    def analyze_review(self, review_text: str, review_rating: float, review_title: str = None, num_trials: int = 5) -> Dict:
        """一つのレビューに対して複数回特徴を分析し、多数決で判定"""
        results = []
        stability_data = {str(i): [] for i in range(1, 21)}  # 各特徴の判定安定性データ
        all_results = []  # 各試行の結果を保存

        # 指定回数の分析を実行
        for trial in range(num_trials):
            result = self._single_analysis(review_text, review_rating)
            if result and 'features' in result:
                results.append(result['features'])
                # 各特徴の判定を記録
                for feature_id, value in result['features'].items():
                    stability_data[feature_id].append(value)
                # 試行結果を保存
                all_results.append({
                    'trial': trial + 1,
                    **result['features']
                })

        if not results:
            return None

        # 多数決による最終判定と安定性の計算
        final_result = {
            'features': self._get_majority_vote(results),
            'stability': self._calculate_stability(stability_data, num_trials),
            'all_trials': all_results  # 各試行の結果を含める
        }

        # 結果をCSVファイルに保存
        self._save_results_to_csv(final_result, review_title)

        return final_result

    def _save_results_to_csv(self, results: Dict, review_title: str = None):
        """分析結果をCSVファイルに保存"""
        # 現在時刻からファイル名を生成
        timestamp = datetime.now().strftime("%H%M")

        # レビュータイトルがある場合は、ファイル名に含める
        if review_title:
            # タイトルから不適切な文字を除去
            safe_title = "".join(c for c in review_title if c.isalnum() or c in [' ', '-', '_'])
            safe_title = safe_title[:50]  # タイトルの長さを制限
            filename = f"{timestamp}_{safe_title}.csv"
        else:
            filename = f"{timestamp}.csv"

        output_file = self.output_dir / filename

        # 出力ディレクトリが存在しない場合は作成
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # 特徴の説明を取得
        feature_descriptions = {
            str(row['feature_id']): row['feature_description']
            for _, row in self.features_df.iterrows()
        }

        # CSVファイルに書き込み
        with open(output_file, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)

            # ヘッダー行を書き込み
            writer.writerow(['Feature ID', 'Description', 'Final Value', 'Stability'] +
                          [f'Trial {i+1}' for i in range(len(results['all_trials']))])

            # 各特徴の結果を書き込み
            for feature_id in range(1, 21):
                feature_id_str = str(feature_id)
                row = [
                    feature_id,
                    feature_descriptions[feature_id_str],
                    results['features'][feature_id_str],
                    f"{results['stability'][feature_id_str]:.2f}"
                ]

                # 各試行の結果を追加
                for trial in results['all_trials']:
                    row.append(trial[feature_id_str])

                writer.writerow(row)

        print(f"\nDetailed results saved to: {output_file}")

### batch_review_analyzer.py
```python
import pandas as pd
from review_feature_analyzer import ReviewFeatureAnalyzer
from datetime import datetime
import json
from pathlib import Path

class BatchReviewAnalyzer:
    def __init__(self, sample_size=300):
        self.sample_size = sample_size
        # 実行開始時の時間を保存
        self.timestamp = datetime.now().strftime("%Y%m%d_%H%M")
        # 出力ディレクトリの設定
        self.output_dir = Path(f"src/analysis/results_batch_analysis/{self.timestamp}")
        # ReviewFeatureAnalyzerに出力ディレクトリを指定
        self.analyzer = ReviewFeatureAnalyzer(output_dir=str(self.output_dir))

    def analyze_reviews(self):
        """サンプルデータを読み込んで分析を実行"""
        # サンプルデータの読み込み
        df = pd.read_csv("src/data/examples/sample_reviews_300.csv")

        # 結果を保存するディレクトリの作成
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # 分析結果を保存するリスト
        all_results = []

        # 進捗表示用のカウンター
        total = len(df)

        print(f"\n=== バッチ分析開始 ===")
        print(f"サンプル数: {total}")
        print(f"出力ディレクトリ: {self.output_dir}\n")

        # 各レビューの分析
        for idx, row in df.iterrows():
            print(f"分析中... {idx + 1}/{total}")

            result = self.analyzer.analyze_review(
                review_text=row['review_text'],
                review_rating=row['rating'],
                review_title=row['summary']
            )

            if result:
                # 結果に元のレビュー情報を追加
                analysis_result = {
                    'review_id': idx,
                    'review_text': row['review_text'],
                    'rating': row['rating'],
                    'product_id': row['product_id'],
                    'summary': row['summary'],
                    'analysis_result': result
                }
                all_results.append(analysis_result)

                # 10件ごとに中間結果を保存
                if (idx + 1) % 10 == 0:
                    self._save_intermediate_results(all_results, self.output_dir, idx + 1)

        # 最終結果の保存
        self._save_final_results(all_results, self.output_dir)

        print(f"\n=== 分析完了 ===")
        print(f"分析結果: {self.output_dir}/all_results.json")
        print(f"サマリーレポート: {self.output_dir}/summary_report.md")

    def _save_intermediate_results(self, results, output_dir, current_count):
        """中間結果を保存"""
        # 中間結果用のディレクトリ
        intermediate_dir = output_dir / "intermediate"
        intermediate_dir.mkdir(exist_ok=True)

        # 結果をJSONファイルとして保存
        with open(intermediate_dir / f"results_{current_count}.json", 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2, ensure_ascii=False)

        print(f"中間結果を保存しました（{current_count}件）")

    def _save_final_results(self, results, output_dir):
        """最終結果を保存"""
        # 全体の結果をJSONファイルとして保存
        with open(output_dir / 'all_results.json', 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2, ensure_ascii=False)

        # サマリーレポートの作成
        self._create_summary_report(results, output_dir)

    def _create_summary_report(self, results, output_dir):
        """分析結果のサマリーレポートを作成"""
        # 特徴の出現頻度を計算
        feature_counts = {str(i): 0 for i in range(1, 21)}
        stability_sums = {str(i): 0.0 for i in range(1, 21)}

        for result in results:
            features = result['analysis_result']['features']
            stability = result['analysis_result']['stability']

            for feature_id in feature_counts.keys():
                if features[feature_id] == 1:
                    feature_counts[feature_id] += 1
                stability_sums[feature_id] += stability[feature_id]

        # レポート作成
        report = f"""# バッチ分析レポート
実行日時: {datetime.now().strftime("%Y-%m-%d %H:%M")}

## 分析概要
- 分析対象レビュー数: {len(results)}
- レーティング分布:
{self._get_rating_distribution(results)}

## 特徴分析結果

| 特徴ID | 出現数 | 出現率 | 平均安定性 |
|--------|--------|--------|------------|
"""

        for feature_id in feature_counts.keys():
            count = feature_counts[feature_id]
            percentage = (count / len(results)) * 100
            avg_stability = stability_sums[feature_id] / len(results)

            report += f"| {feature_id} | {count} | {percentage:.1f}% | {avg_stability:.2f} |\n"

        # レポートの保存
        with open(output_dir / 'summary_report.md', 'w', encoding='utf-8') as f:
            f.write(report)

    def _get_rating_distribution(self, results):
        """レーティングの分布を文字列として返す"""
        ratings = [r['rating'] for r in results]
        distribution = pd.Series(ratings).value_counts().sort_index()

        result = ""
        for rating, count in distribution.items():
            percentage = (count / len(results)) * 100
            result += f"  - {rating}星: {count}件 ({percentage:.1f}%)\n"

        return result

if __name__ == "__main__":
    analyzer = BatchReviewAnalyzer(sample_size=300)
    analyzer.analyze_reviews()
````
